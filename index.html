<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>[Fss-angel] (https://github.com/Fss-angel/Fss-angel.github.io.git)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="[Fss-angel] (https:&#x2F;&#x2F;github.com&#x2F;Fss-angel&#x2F;Fss-angel.github.io.git)">
<meta property="og:url" content="http://fss-angel.top/index.html">
<meta property="og:site_name" content="[Fss-angel] (https:&#x2F;&#x2F;github.com&#x2F;Fss-angel&#x2F;Fss-angel.github.io.git)">
<meta property="og:locale">
<meta property="article:author" content="FSS-ANGEL">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="[Fss-angel] (https://github.com/Fss-angel/Fss-angel.github.io.git)" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">[Fss-angel] (https://github.com/Fss-angel/Fss-angel.github.io.git)</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://Fss-angel.top"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-CNF" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/25/CNF/" class="article-date">
  <time class="dt-published" datetime="2021-04-25T00:49:47.000Z" itemprop="datePublished">2021-04-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/25/CNF/">CNF</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://fss-angel.top/2021/04/25/CNF/" data-id="cknwgwvfw00000ko25yebgczt" data-title="CNF" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-vscode-set-get-executionPolicy" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/24/vscode-set-get-executionPolicy/" class="article-date">
  <time class="dt-published" datetime="2021-03-24T00:38:21.000Z" itemprop="datePublished">2021-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/24/vscode-set-get-executionPolicy/">vscode set/get-executionPolicy</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>检测get-ExecutionPolicy 状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get-ExecutionPolicy</span><br></pre></td></tr></table></figure>
<p>如果禁止状态</p>
<p>设置set-ExecutionPolicy</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set-ExecutionPolicy RemoteSigned</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://fss-angel.top/2021/03/24/vscode-set-get-executionPolicy/" data-id="ckmoqbunm0004gko2aselbveo" data-title="vscode set/get-executionPolicy" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-C中预编译宏" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/22/C%E4%B8%AD%E9%A2%84%E7%BC%96%E8%AF%91%E5%AE%8F/" class="article-date">
  <time class="dt-published" datetime="2021-03-22T08:10:36.000Z" itemprop="datePublished">2021-03-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/22/C%E4%B8%AD%E9%A2%84%E7%BC%96%E8%AF%91%E5%AE%8F/">C中预编译宏</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="一-预处理命令简介"><a href="#一-预处理命令简介" class="headerlink" title="(一) 预处理命令简介"></a>(一) 预处理命令简介</h1><p>注意: 函数宏对参数类型是不敏感的, 你不必考虑将何种数据类型传递给宏. 那么, 如何构建对参数类型敏感的宏呢? 参考本章的第九部分, 关于”##”的介绍.</p>
<p>关于定义宏的另外一些问题</p>
<h3 id="1-宏可以被多次定义-前提是这些定义必须是相同的-这里的”相同”要求先后定义中空白符出现的位置相同-但具体的空白符类型或数量可不同-比如原先的空格可替换为多个其他类型的空白符-可为tab-注释"><a href="#1-宏可以被多次定义-前提是这些定义必须是相同的-这里的”相同”要求先后定义中空白符出现的位置相同-但具体的空白符类型或数量可不同-比如原先的空格可替换为多个其他类型的空白符-可为tab-注释" class="headerlink" title="(1) 宏可以被多次定义, 前提是这些定义必须是相同的. 这里的”相同”要求先后定义中空白符出现的位置相同, 但具体的空白符类型或数量可不同, 比如原先的空格可替换为多个其他类型的空白符: 可为tab, 注释"></a>(1) 宏可以被多次定义, 前提是这些定义必须是相同的. 这里的”相同”要求先后定义中空白符出现的位置相同, 但具体的空白符类型或数量可不同, 比如原先的空格可替换为多个其他类型的空白符: 可为tab, 注释</h3><p><strong>e.g.</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL　<span class="comment">/* null pointer */</span>     0</span></span><br></pre></td></tr></table></figure>
<p>上面的重定义是相同的, 但下面的重定义不同:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fun(x) x+1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fun(x) x + 1 或: #<span class="meta-keyword">define</span> fun(y) y+1</span></span><br></pre></td></tr></table></figure>

<p>如果多次定义时, 再次定义的宏内容是不同的, gcc会给出”NAME redefined”警告信息.</p>
<p>应该避免重新定义函数宏, 不管是在预处理命令中还是C语句中, 最好对某个对象只有单一的定义. 在gcc中, 若宏出现了重定义, gcc会给出警告.</p>
<h3 id="2-在gcc中-可在命令行中指定对象宏的定义"><a href="#2-在gcc中-可在命令行中指定对象宏的定义" class="headerlink" title="(2) 在gcc中, 可在命令行中指定对象宏的定义:"></a>(2) 在gcc中, 可在命令行中指定对象宏的定义:</h3><p><strong>e.g.</strong></p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -Wall -DMAX=<span class="number">100</span> -o tmp tmp.c</span><br></pre></td></tr></table></figure>
<p>相当于在tmp.c中添加” #define MAX 100”.</p>
<p>那么, 如果原先tmp.c中含有MAX宏的定义, 那么再在gcc调用命令中使用-DMAX, 会出现什么情况呢?<br>—若-DMAX=1, 则正确编译.<br>—若-DMAX的值被指定为不为1的值, 那么gcc会给出MAX宏被重定义的警告, MAX的值仍为1.</p>
<p>注意: 若在调用gcc的命令行中不显示地给出对象宏的值, 那么gcc赋予该宏默认值(1), 如: -DVAL == -DVAL=1</p>
<h3 id="3-define所定义的宏的作用域"><a href="#3-define所定义的宏的作用域" class="headerlink" title="(3) #define所定义的宏的作用域"></a>(3) #define所定义的宏的作用域</h3><p>宏在定义之后才生效, 若宏定义被#undef取消, 则#undef之后该宏无效. 并且字符串中的宏不会被识别<br><strong>e.g.</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define ONE 1</span><br><span class="line">sum &#x3D; ONE + TWO    &#x2F;* sum &#x3D; 1 + TWO *&#x2F;</span><br><span class="line">#define TWO 2</span><br><span class="line">sum &#x3D; ONE + TWO    &#x2F;* sum &#x3D; 1 + 2    *&#x2F; </span><br><span class="line">#undef ONE</span><br><span class="line">sum &#x3D; ONE + TWO    &#x2F;* sum &#x3D; ONE + 2 *&#x2F;</span><br><span class="line"></span><br><span class="line">char c[] &#x3D; &quot;TWO&quot;   &#x2F;* c[] &#x3D; &quot;TWO&quot;, NOT &quot;2&quot;! *&#x2F;</span><br></pre></td></tr></table></figure>
<h3 id="4-宏的替换可以是递归的-所以可以嵌套定义宏"><a href="#4-宏的替换可以是递归的-所以可以嵌套定义宏" class="headerlink" title="(4) 宏的替换可以是递归的, 所以可以嵌套定义宏."></a>(4) 宏的替换可以是递归的, 所以可以嵌套定义宏.</h3><p><strong>e.g.</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define ONE NUMBER_1</span><br><span class="line">#define NUMBER_1 1</span><br><span class="line">int a &#x3D; ONE &#x2F;* a &#x3D; 1 *&#x2F;</span><br></pre></td></tr></table></figure>
<h2 id="2-undef"><a href="#2-undef" class="headerlink" title="2, #undef"></a>2, #undef</h2><p>#undef用来取消宏定义, 它与#define对立:<br>#undef name<br>如够被取消的宏实际上没有被#define所定义, 针对它的#undef并不会产生错误.<br>当一个宏定义被取消后, 可以再度定义它. </p>
<h2 id="3-if-elif-else-endif"><a href="#3-if-elif-else-endif" class="headerlink" title="3, #if, #elif, #else, #endif"></a>3, #if, #elif, #else, #endif</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#if, #elif, #else, #endif用于条件编译:</span><br><span class="line"></span><br><span class="line">#if 常量表达式1</span><br><span class="line">   语句...</span><br><span class="line">#elif 常量表达式2</span><br><span class="line">   语句...</span><br><span class="line">#elif 常量表达式3</span><br><span class="line">   语句...</span><br><span class="line">...</span><br><span class="line">#else</span><br><span class="line">   语句...</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>#if和#else分别相当于C语句中的if, else. 它们根据常量表达式的值来判别是否执行后面的语句. #elif相当于C中的else-if. 使用这些条件编译命令可以方便地实现对源代码内容的控制.<br>else之后不带常量表达式, 但若包含了常量表达式, gcc只是给出警告信息.</p>
<p>使用它们可以提升代码的可移植性—针对不同的平台使用执行不同的语句. 也经常用于大段代码注释.<br><strong>e.g.</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#if 0</span><br><span class="line">&#123;</span><br><span class="line">   一大段代码;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>常量表达式可以是包含宏, 算术运算, 逻辑运算等等的合法C常量表达式, 如果常量表达式为一个未定义的宏, 那么它的值被视为0.<br>#if MACRO_NON_DEFINED == #if 0<br>在判断某个宏是否被定义时, 应当避免使用#if, 因为该宏的值可能就是被定义为0. 而应当使用下面介绍的#ifdef或#ifndef.</p>
<p>注意: #if, #elif, #else之后的宏只能是对象宏. 如果name为名的宏未定义, 或者该宏是函数宏. 那么在gcc中使用”-Wundef”选项会显示宏未定义的警告信息.</p>
<h2 id="4-ifdef-ifndef-defined"><a href="#4-ifdef-ifndef-defined" class="headerlink" title="4, #ifdef, #ifndef, defined."></a>4, #ifdef, #ifndef, defined.</h2><p>#ifdef, #ifndef, defined用来测试某个宏是否被定义<br>#ifdef name 或 #ifndef name</p>
<p>它们经常用于避免头文件的重复引用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#ifndef __FILE_H__</span><br><span class="line">#define __FILE_H__</span><br><span class="line">#include &quot;file.h&quot;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>defined(name): 若宏被定义,则返回1, 否则返回0.<br>它与#if, #elif, #else结合使用来判断宏是否被定义, 乍一看好像它显得多余, 因为已经有了#ifdef和#ifndef. defined用于在一条判断语句中声明多个判别条件:</p>
<p>#if defined(VAX) &amp;&amp; defined(UNIX) &amp;&amp; !defined(DEBUG) </p>
<p>和#if, #elif, #else不同, #indef, #ifndef, defined测试的宏可以是对象宏, 也可以是函数宏. 在gcc中使用”-Wundef”选项不会显示宏未定义的警告信息.</p>
<h2 id="5-include-include-next"><a href="#5-include-include-next" class="headerlink" title="5, #include , #include_next"></a>5, #include , #include_next</h2><p>#include用于文件包含. 在#include 命令所在的行不能含有除注释和空白符之外的其他任何内容.<br>#include “headfile”<br>#include <headfile><br>#include 预处理标记<br>前面两种形式大家都很熟悉, “#include 预处理标记”中, 预处理标记会被预处理器进行替换, 替换的结果必须符合前两种形式中的某一种.</p>
<p>实际上, 真正被添加的头文件并不一定就是#include中所指定的文件. #include”headfile”包含的头文件当然是同一个文件, 但#include <headfile>包包含的”系统头文件”可能是另外的文件. 但这不值得被注意. 感兴趣的话可以查看宏扩展后到底引入了哪些系统头文件.</p>
<p>关于#include “headfile”和#include <headfile>的区别以及如何在gcc中包含头文件的详细信息, 参考本blog的GCC笔记.</p>
<p>相对于#include, 我们对#include_next不太熟悉. #include_next仅用于特殊的场合. 它被用于头文件中(#include既可用于头文件中, 又可用于.c文件中)来包含其他的头文件. 而且包含头文件的路径比较特殊: 从当前头文件所在目录之后的目录来搜索头文件.<br>比如: 头文件的搜索路径一次为A,B,C,D,E. #include_next所在的当前头文件位于B目录, 那么#include_next使得预处理器从C,D,E目录来搜索#include_next所指定的头文件.</p>
<p>可参考cpp手册进一步了解#include_next</p>
<h2 id="6-预定义宏"><a href="#6-预定义宏" class="headerlink" title="6, 预定义宏"></a>6, 预定义宏</h2><p>标准C中定义了一些对象宏, 这些宏的名称以”__”开头和结尾, 并且都是大写字符. 这些预定义宏可以被#undef, 也可以被重定义.</p>
<p>下面列出一些标准C中常见的预定义对象宏(其中也包含gcc自己定义的一些预定义宏:<br>__LINE__         当前语句所在的行号, 以10进制整数标注.<br>__FILE__         当前源文件的文件名, 以字符串常量标注.<br>__DATE__          程序被编译的日期, 以”Mmm dd yyyy”格式的字符串标注.<br>__TIME__           程序被编译的时间, 以”hh:mm:ss”格式的字符串标注, 该时间由asctime返回.</p>
<p>__STDC__           如果当前编译器符合ISO标准, 那么该宏的值为1<br>__STDC_VERSION__   如果当前编译器符合C89, 那么它被定义为199409L, 如果符合C99, 那么被定义为199901L.<br>                   我用gcc, 如果不指定-std=c99, 其他情况都给出__STDC_VERSION__未定义的错误信息, 咋回事呢?<br>__STDC_HOSTED__     如果当前系统是”本地系统(hosted)”, 那么它被定义为1. 本地系统表示当前系统拥有完整的标准C库.</p>
<p>gcc定义的预定义宏:<br>__OPTMIZE__         如果编译过程中使用了优化, 那么该宏被定义为1.<br>__OPTMIZE_SIZE__   同上, 但仅在优化是针对代码大小而非速度时才被定义为1.<br>__VERSION__         显示所用gcc的版本号.<br>可参考”GCC the complete reference”.<br>要想看到gcc所定义的所有预定义宏, 可以运行: $ cpp -dM /dev/null</p>
<h2 id="7-line"><a href="#7-line" class="headerlink" title="7, #line"></a>7, #line</h2><p>#line用来修改__LINE__和__FILE__.<br><strong>e.g.</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;line: %d, file: %s\n&quot;, \_\_LINE__, \_\_FILE__);</span><br><span class="line">#line 100 &quot;haha&quot;</span><br><span class="line">printf(&quot;line: %d, file: %s\n&quot;, \_\_LINE__, \_\_FILE__);</span><br><span class="line">printf(&quot;line: %d, file: %s\n&quot;, \_\_LINE__, \_\_FILE__);</span><br></pre></td></tr></table></figure>
<p>显示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">line: 34, file: 1.c</span><br><span class="line">line: 100, file: haha</span><br><span class="line">line: 101, file: haha </span><br></pre></td></tr></table></figure>
<h2 id="8-pragma-Pragma"><a href="#8-pragma-Pragma" class="headerlink" title="8, #pragma, _Pragma"></a>8, #pragma, _Pragma</h2><p>#pragma用编译器用来添加新的预处理功能或者显示一些编译信息. #pragma的格式是各编译器特定的, gcc的如下:<br>#pragma GCC name token(s)</p>
<p>#pragma之后有两个部分: GCC和特定的pragma name. 下面分别介绍gcc中常用的.</p>
<h3 id="1-pragma-GCC-dependency"><a href="#1-pragma-GCC-dependency" class="headerlink" title="(1) #pragma GCC dependency"></a>(1) #pragma GCC dependency</h3><p>dependency测试当前文件(既该语句所在的程序代码)与指定文件(既#pragma语句最后列出的文件)的时间戳. 如果指定文件比当前文件新, 则给出警告信息.<br><strong>e.g.</strong><br>在demo.c中给出这样一句:<br><code>#pragma GCC dependency &quot;temp-file&quot;</code><br>然后在demo.c所在的目录新建一个更新的文件: $ touch temp-file, 编译: $ gcc demo.c 会给出这样的警告信息: warning: current file is older than temp-file<br>如果当前文件比指定的文件新, 则不给出任何警告信息.</p>
<p>还可以在在#pragma中给添加自定义的警告信息.<br><strong>e.g.</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#pragma GCC dependency &quot;temp-file&quot; &quot;demo.c needs to be updated!&quot;</span><br><span class="line">1.c:27:38: warning: extra tokens at end of #pragma directive</span><br><span class="line">1.c:27:38: warning: current file is older than temp-file</span><br></pre></td></tr></table></figure>
<p>注意: 后面新增的警告信息要用””引用起来, 否则gcc将给出警告信息.</p>
<h3 id="2-pragma-GCC-poison-token-s"><a href="#2-pragma-GCC-poison-token-s" class="headerlink" title="(2) #pragma GCC poison token(s)"></a>(2) #pragma GCC poison token(s)</h3><p>若源代码中出现了#pragma中给出的token(s), 则编译时显示警告信息. 它一般用于在调用你不想使用的函数时候给出出错信息.<br><strong>e.g.</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#pragma GCC poison scanf</span><br><span class="line">scanf(&quot;%d&quot;, &amp;a); </span><br><span class="line">warning: extra tokens at end of #pragma directive</span><br><span class="line">error: attempt to use poisoned &quot;scanf&quot;</span><br></pre></td></tr></table></figure>
<p>注意, 如果调用了poison中给出的标记, 那么编译器会给出的是出错信息. 关于第一条警告, 我还不知道怎么避免, 用””将token(s)引用起来也不行.</p>
<h3 id="3-pragma-GCC-system-header"><a href="#3-pragma-GCC-system-header" class="headerlink" title="(3) #pragma GCC system_header"></a>(3) #pragma GCC system_header</h3><p>从#pragma GCC system_header直到文件结束之间的代码会被编译器视为系统头文件之中的代码. 系统头文件中的代码往往不能完全遵循C标准, 所以头文件之中的警告信息往往不显示. (除非用 #warning显式指明).<br>(这条#pragma语句还没发现用什么大的用处)</p>
<p>由于#pragma不能用于宏扩展, 所以gcc还提供了_Pragma:<br><strong>e.g.</strong><br><code>#define PRAGMA_DEP #pragma GCC dependency &quot;temp-file&quot;</code><br>由于预处理之进行一次宏扩展, 采用上面的方法会在编译时引发错误, 要将#pragma语句定义成一个宏扩展, 应该使用下面的_Pragma语句:<br><code>#define PRAGMA_DEP _Pragma(&quot;GCC dependency \&quot;temp-file\&quot;&quot;)</code><br>注意, ()中包含的””引用之前引该加上\转义字符.</p>
<h2 id="9"><a href="#9" class="headerlink" title="9, #,"></a>9, #,</h2><p>#和##用于对字符串的预处理操作, 所以他们也经常用于printf, puts之类的字符串显示函数中.<br>#用于在宏扩展之后将tokens转换为以tokens为内容的字符串常量.<br><strong>e.g.</strong><br><code>#define TEST(a,b) printf( #a &quot;&lt;&quot; #b &quot;=%d\n&quot;, (a)&lt;(b));</code><br>注意: #只针对紧随其后的token有效!<br>##用于将它前后的两个token组合在一起转换成以这两个token为内容的字符串常量. 注意##前后必须要有token.<br><strong>e.g.</strong><br><code>#define TYPE(type, n) type n</code></p>
<p>之后调用: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TYPE(int, a) &#x3D; 1;</span><br><span class="line">TYPE(long, b) &#x3D; 1999;</span><br></pre></td></tr></table></figure>
<p>将被替换为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a &#x3D; 1;</span><br><span class="line">long b &#x3D; 1999;</span><br></pre></td></tr></table></figure>
<h3 id="10-warning-error"><a href="#10-warning-error" class="headerlink" title="(10) #warning, #error"></a>(10) #warning, #error</h3><p>#warning, #error分别用于在编译时显示警告和错误信息, 格式如下:<br>#warning tokens<br>#error tokens<br><strong>e.g.</strong><br><code>#warning &quot;some warning&quot;</code><br>注意, #error和#warning后的token要用””引用起来!<br>(在gcc中, 如果给出了warning, 编译继续进行, 但若给出了error, 则编译停止. 若在命令行中指定了 -Werror, 即使只有警告信息, 也不编译.</p>
<p>预处理命令由#(hash字符)开头, 它独占一行, #之前只能是空白符. 以#开头的语句就是预处理命令, 不以#开头的语句为C中的代码行. 常用的预处理命令如下:</p>
<p>#define              定义一个预处理宏<br>#undef             取消宏的定义</p>
<p>#include            包含文件命令<br>#include_next   与#include相似, 但它有着特殊的用途</p>
<p>#if                      编译预处理中的条件命令, 相当于C语法中的if语句<br>#ifdef                判断某个宏是否被定义, 若已定义, 执行随后的语句<br>#ifndef             与#ifdef相反, 判断某个宏是否未被定义<br>#elif                  若#if, #ifdef, #ifndef或前面的#elif条件不满足, 则执行#elif之后的语句, 相当于C语法中的else-if<br>#else                与#if, #ifdef, #ifndef对应, 若这些条件不满足, 则执行#else之后的语句, 相当于C语法中的else<br>#endif              #if, #ifdef, #ifndef这些条件命令的结束标志.<br>defined          与#if, #elif配合使用, 判断某个宏是否被定义</p>
<p>#line                标志该语句所在的行号</p>
<h1 id="将宏参数替代为以参数值为内容的字符窜常量"><a href="#将宏参数替代为以参数值为内容的字符窜常量" class="headerlink" title="将宏参数替代为以参数值为内容的字符窜常量"></a>将宏参数替代为以参数值为内容的字符窜常量</h1><h2 id="将两个相邻的标记-token-连接为一个单独的标记"><a href="#将两个相邻的标记-token-连接为一个单独的标记" class="headerlink" title="将两个相邻的标记(token)连接为一个单独的标记"></a>将两个相邻的标记(token)连接为一个单独的标记</h2><p>#pragma       说明编译器信息</p>
<p>#warning       显示编译警告信息<br>#error          显示编译错误信息</p>
<h1 id="二-预处理的文法"><a href="#二-预处理的文法" class="headerlink" title="(二) 预处理的文法"></a>(二) 预处理的文法</h1><p>预处理并不分析整个源代码文件, 它只是将源代码分割成一些标记(token), 识别语句中哪些是C语句, 哪些是预处理语句. 预处理器能够识别C标记, 文件名, 空白符, 文件结尾标志.</p>
<p>预处理语句格式:    #command name(…) token(s)</p>
<h2 id="1-command预处理命令的名称-它之前以-开头-之后紧随预处理命令-标准C允许-两边可以有空白符-但比较老的编译器可能不允许这样-若某行中只包含-以及空白符-那么在标准C中该行被理解为空白-整个预处理语句之后只能有空白符或者注释-不能有其它内容"><a href="#1-command预处理命令的名称-它之前以-开头-之后紧随预处理命令-标准C允许-两边可以有空白符-但比较老的编译器可能不允许这样-若某行中只包含-以及空白符-那么在标准C中该行被理解为空白-整个预处理语句之后只能有空白符或者注释-不能有其它内容" class="headerlink" title="1, command预处理命令的名称, 它之前以#开头, #之后紧随预处理命令, 标准C允许#两边可以有空白符, 但比较老的编译器可能不允许这样. 若某行中只包含#(以及空白符), 那么在标准C中该行被理解为空白. 整个预处理语句之后只能有空白符或者注释, 不能有其它内容."></a>1, command预处理命令的名称, 它之前以#开头, #之后紧随预处理命令, 标准C允许#两边可以有空白符, 但比较老的编译器可能不允许这样. 若某行中只包含#(以及空白符), 那么在标准C中该行被理解为空白. 整个预处理语句之后只能有空白符或者注释, 不能有其它内容.</h2><h2 id="2-name代表宏名称-它可带参数-参数可以是可变参数列表-C99"><a href="#2-name代表宏名称-它可带参数-参数可以是可变参数列表-C99" class="headerlink" title="2, name代表宏名称, 它可带参数. 参数可以是可变参数列表(C99)."></a>2, name代表宏名称, 它可带参数. 参数可以是可变参数列表(C99).</h2><h2 id="3-语句中可以利用”-quot-来换行"><a href="#3-语句中可以利用”-quot-来换行" class="headerlink" title="3, 语句中可以利用”&quot;来换行."></a>3, 语句中可以利用”&quot;来换行.</h2><p><strong>e.g.</strong><br><code># define ONE 1 /* ONE == 1 */</code><br>等价于: #define ONE　１</p>
<p><code>#define err(flag, msg) if(flag) \</code><br>   printf(msg)<br>等价于: #define err(flag, msg) if(flag) printf(msg)</p>
<h1 id="三-预处理命令详述"><a href="#三-预处理命令详述" class="headerlink" title="(三) 预处理命令详述"></a>(三) 预处理命令详述</h1><h2 id="1-define"><a href="#1-define" class="headerlink" title="1, #define"></a>1, #define</h2><p>#define命令定义一个宏:<br>#define MACRO_NAME(args) tokens(opt)<br>之后出现的MACRO_NAME将被替代为所定义的标记(tokens). 宏可带参数, 而后面的标记也是可选的.</p>
<p><strong>对象宏</strong><br>不带参数的宏被称为”对象宏(objectlike macro)”</p>
<p>#define经常用来定义常量, 此时的宏名称一般为大写的字符串. 这样利于修改这些常量.<br><strong>e.g.</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define MAX 100</span><br><span class="line">int a[MAX];</span><br><span class="line"></span><br><span class="line">#ifndef __FILE_H__</span><br><span class="line">#define __FILE_H__</span><br><span class="line">#include &quot;file.h&quot;</span><br><span class="line">#endif</span><br><span class="line">#define __FILE_H__ 中的宏就不带任何参数, 也不扩展为任何标记. 这经常用于包含头文件.</span><br></pre></td></tr></table></figure>
<p>要调用该宏, 只需在代码中指定宏名称, 该宏将被替代为它被定义的内容.</p>
<p><strong>函数宏</strong><br>带参数的宏也被称为”函数宏”. 利用宏可以提高代码的运行效率: 子程序的调用需要压栈出栈, 这一过程如果过于频繁会耗费掉大量的CPU运算资源. 所以一些代码量小但运行频繁的代码如果采用带参数宏来实现会提高代码的运行效率.</p>
<p>函数宏的参数是固定的情况</p>
<p>函数宏的定义采用这样的方式: #define name( args ) tokens<br>其中的args和tokens都是可选的. 它和对象宏定义上的区别在于宏名称之后不带括号.</p>
<p>注意, name之后的左括号(必须紧跟name, 之间不能有空格, 否则这就定义了一个对象宏, 它将被替换为 以(开始的字符串. 但在调用函数宏时, name与(之间可以有空格.</p>
<p><strong>e.g.</strong><br><code>#define mul(x,y) ((x)*(y))</code></p>
<p>注意, 函数宏之后的参数要用括号括起来, 看看这个例子:<br><strong>e.g.</strong><br><code>#define mul(x,y) x*y</code><br>“mul(1, 2+2);” 将被扩展为: 1*2 + 2<br>同样, 整个标记串也应该用括号引用起来:<br><strong>e.g.</strong><br><code>#define mul(x,y) (x)*(y)</code><br>sizeof mul(1,2.0) 将被扩展为 sizeof 1 * 2.0</p>
<p>调用函数宏时候, 传递给它的参数可以是函数的返回值, 也可以是任何有意义的语句:<br><strong>e.g.</strong><br><code>mul (f(a,b), g(c,d));</code></p>
<p><strong>e.g.</strong><br><code>#define insert(stmt) stmt</code><br>insert ( a=1; b=2;) 相当于在代码中加入 a=1; b=2 .<br>insert ( a=1, b=2;) 就有问题了: 预处理器会提示出错: 函数宏的参数个数不匹配. 预处理器把”,”视为参数间的分隔符.<br>insert ((a=1, b=2;)) 可解决上述问题.</p>
<p>在定义和调用函数宏时候, 要注意一些问题:</p>
<h2 id="1-我们经常用-来引用函数宏被定义的内容-这就要注意调用这个函数宏时的”-”问题"><a href="#1-我们经常用-来引用函数宏被定义的内容-这就要注意调用这个函数宏时的”-”问题" class="headerlink" title="1, 我们经常用{}来引用函数宏被定义的内容, 这就要注意调用这个函数宏时的”;”问题."></a>1, 我们经常用{}来引用函数宏被定义的内容, 这就要注意调用这个函数宏时的”;”问题.</h2><p>example_3.7:<br>#define swap(x,y) { unsigned long _temp=x; x=y; y=_tmp}<br>如果这样调用它: “swap(1,2);” 将被扩展为: { unsigned long _temp=1; 1=2; 2=_tmp};<br>明显后面的;是多余的, 我们应该这样调用: swap(1,2)<br>虽然这样的调用是正确的, 但它和C语法相悖, 可采用下面的方法来处理被{}括起来的内容:</p>
<p>#define swap(x,y) <br>   do { unsigned long _temp=x; x=y; y=_tmp} while (0)<br>swap(1,2); 将被替换为:<br>do { unsigned long _temp=1; 1=2; 2=_tmp} while (0);<br>在Linux内核源代码中对这种do-while(0)语句有这广泛的应用.</p>
<h2 id="2-有的函数宏是无法用do-while-0-来实现的-所以在调用时不能带上”-”-最好在调用后添加注释说明"><a href="#2-有的函数宏是无法用do-while-0-来实现的-所以在调用时不能带上”-”-最好在调用后添加注释说明" class="headerlink" title="2, 有的函数宏是无法用do-while(0)来实现的, 所以在调用时不能带上”;”, 最好在调用后添加注释说明."></a>2, 有的函数宏是无法用do-while(0)来实现的, 所以在调用时不能带上”;”, 最好在调用后添加注释说明.</h2><p>eg_3.8:<br>#define incr(v, low, high) <br>   for ((v) = (low),; (v) &lt;= (high); (v)++)<br>只能以这样的形式被调用: incr(a, 1, 10) /* increase a form 1 to 10 */</p>
<p>函数宏中的参数包括可变参数列表的情况<br>C99标准中新增了可变参数列表的内容. 不光是函数, 函数宏中也可以使用可变参数列表.</p>
<p>#define name(args, …) tokens<br>#define name(…) tokens<br>“…”代表可变参数列表, 如果它不是仅有的参数, 那么它只能出现在参数列表的最后. 调用这样的函数宏时, 传递给它的参数个数要不少于参数列表中参数的个数(多余的参数被丢弃).<br>通过__VA_ARGS__来替换函数宏中的可变参数列表. 注意__VA_ARGS__只能用于函数宏中参数中包含有”…”的情况.</p>
<p><strong>e.g.</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifdef DEBUG</span><br><span class="line">#define my_printf(...) fprintf(stderr, __VA_ARGS__)</span><br><span class="line">#else</span><br><span class="line">#define my_printf(...) printf(__VA_ARGS__)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>tokens中的__VA_ARGS__被替换为函数宏定义中的”…”可变参数列表. </p>
<p>注意在使用#define时候的一些常见错误:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define MAX &#x3D; 100</span><br><span class="line">#define MAX 100;</span><br></pre></td></tr></table></figure>
<p>=, ; 的使用要值得注意. 再就是调用函数宏是要注意, 不要多给出”;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://fss-angel.top/2021/03/22/C%E4%B8%AD%E9%A2%84%E7%BC%96%E8%AF%91%E5%AE%8F/" data-id="ckmoqbunt0005gko2e01r0ci7" data-title="C中预编译宏" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-ssh-keygen" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/20/ssh-keygen/" class="article-date">
  <time class="dt-published" datetime="2021-03-20T01:04:44.232Z" itemprop="datePublished">2021-03-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/20/ssh-keygen/">ssh-key-Generate a new SSH Key</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="ssh-keygen-Generate-a-new-SSH-Key"><a href="#ssh-keygen-Generate-a-new-SSH-Key" class="headerlink" title="ssh-keygen-Generate a new SSH Key"></a>ssh-keygen-Generate a new SSH Key</h1><h1 id="Whate-is-ssh-keygen"><a href="#Whate-is-ssh-keygen" class="headerlink" title="Whate is ssh-keygen?"></a>Whate is ssh-keygen?</h1><p>Ssh-keygen 是为SSH创建新的认证密钥对的工具，这样的密钥对用于自动登录，单点登录和主机认证。</p>
<h2 id="The-simplest-way-to-generate-a-key-pair"><a href="#The-simplest-way-to-generate-a-key-pair" class="headerlink" title="The simplest way to generate a key pair"></a>The simplest way to generate a key pair</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure>
<h3 id="choosing-an-Algorithm-and-key-size"><a href="#choosing-an-Algorithm-and-key-size" class="headerlink" title="choosing an Algorithm and key size"></a>choosing an Algorithm and key size</h3><ul>
<li>rsa</li>
<li>dsa</li>
<li>ecdsa</li>
<li>ed25519</li>
</ul>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用 -t选择算法,用 -b确定键的大小</span><br><span class="line">ssh-keygen -t rsa -b <span class="number">4096</span></span><br></pre></td></tr></table></figure>
<h4 id="Specifying-the-File-Name"><a href="#Specifying-the-File-Name" class="headerlink" title="Specifying the File Name"></a>Specifying the File Name</h4><p>用 -f<finename>指定文件</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -f ./tatu-key-rsa -t ras -b <span class="number">521</span></span><br></pre></td></tr></table></figure>
<h1 id="Command-and-Option-S"><a href="#Command-and-Option-S" class="headerlink" title="Command and Option S"></a>Command and Option S</h1><p><strong>-e</strong> “Export” This option allows reformatting of existing keys between the OpenSSH key file format and the format documented in RFC 4716, “SSH Public Key File Format”.</p>
<p><strong>-p</strong> “Change the passphrase” This option allows changing the passphrase of a private key file with [-P old_passphrase] and [-N new_passphrase], [-f keyfile].</p>
<p><strong>-t</strong> “Type” This option specifies the type of key to be created. Commonly used values are: - rsa for RSA keys - dsa for DSA keys - ecdsa for elliptic curve DSA keys</p>
<p><strong>-i</strong> “Input” When ssh-keygen is required to access an existing key, this option designates the file.</p>
<p><strong>-f</strong> “File” Specifies name of the file in which to store the created key.</p>
<p><strong>-N</strong> “New” Provides a new passphrase for the key.</p>
<p><strong>-P</strong> “Passphrase” Provides the (old) passphrase when reading a key.</p>
<p><strong>-c</strong> “Comment” Changes the comment for a keyfile.</p>
<p><strong>-p</strong> Change the passphrase of a private key file.</p>
<p><strong>-q</strong> Silence ssh-keygen.</p>
<p><strong>-v</strong> Verbose mode.</p>
<p><strong>-l</strong> “Fingerprint” Print the fingerprint of the specified public key.</p>
<p><strong>-B</strong> “Bubble babble” Shows a “bubble babble” (Tectia format) fingerprint of a keyfile.</p>
<p><strong>-F</strong> Search for a specified hostname in a known_hosts file.</p>
<p><strong>-R</strong> Remove all keys belonging to a hostname from a known_hosts file.</p>
<p><strong>-y</strong> Read a private OpenSSH format file and print an OpenSSH public key to stdout.</p>
<p>This only listed the most commonly used options. For full usage, including the more exotic and special-purpose options, use the man ssh-keygen command.ummary</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://fss-angel.top/2021/03/20/ssh-keygen/" data-id="ckmoqbunl0003gko20uup2hdj" data-title="ssh-key-Generate a new SSH Key" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/18/hello-world/" class="article-date">
  <time class="dt-published" datetime="2021-03-18T13:05:04.292Z" itemprop="datePublished">2021-03-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/18/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://fss-angel.top/2021/03/18/hello-world/" data-id="ckmoqbunk0002gko2ggavbclc" data-title="Hello World" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Markdown-cheatsheet" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/18/Markdown-cheatsheet/" class="article-date">
  <time class="dt-published" datetime="2021-03-18T12:49:06.000Z" itemprop="datePublished">2021-03-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/18/Markdown-cheatsheet/">Markdown cheatsheet</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h2 id="Headers"><a href="#Headers" class="headerlink" title="Headers"></a><a href="#Headers">Headers</a></h2><h2 id="Anchor"><a href="#Anchor" class="headerlink" title="Anchor"></a><a href="#Anchor">Anchor</a></h2><h2 id="images"><a href="#images" class="headerlink" title="images"></a><a href="#images">images</a></h2><h1 id="Headers-1"><a href="#Headers-1" class="headerlink" title="Headers"></a>Headers</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line">...</span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure>

<h1 id="Anchor-1"><a href="#Anchor-1" class="headerlink" title="Anchor"></a>Anchor</h1><p>  网页中，锚点其实就是页内超链接，也就是链接本文档内部的某些元素，实现当前页面中的跳转。比如我这里写下一个锚点，点击回到目录，就能跳转到目录。 在目录中点击这一节，就能跳过来。还有下一节的注脚。这些根本上都是用锚点来实现的。</p>
<p>  <strong>语法描述：</strong><br>在你准备跳转到的指定标题后插入锚点&#123;#标记&#125;，然后在文档的其它地方写上连接到锚点的链接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">## 目录</span><br><span class="line"></span><br><span class="line">跳转[目录](#目录)</span><br></pre></td></tr></table></figure>

<h1 id="Images"><a href="#Images" class="headerlink" title="Images"></a>Images</h1><h2 id="插入本地图片"><a href="#插入本地图片" class="headerlink" title="插入本地图片"></a>插入本地图片</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  只需要在基础语法的括号中填入图片的位置路径即可，支持绝对路径和相对路径。</span><br><span class="line">例如：</span><br></pre></td></tr></table></figure>
<p>  !<a href="/home/picture/1.png">alt text</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 插入网络图片</span><br><span class="line">  只需要在基础语法的括号中填入图片的网络链接即可，现在已经有很多免费&#x2F;收费图床和方便传图的小工具可选。</span><br><span class="line">例如：</span><br></pre></td></tr></table></figure>
<p>  !<a target="_blank" rel="noopener" href="https://baidu.com/pic/doge.png">alt text</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 把图片嵌入Markdown文件中</span><br></pre></td></tr></table></figure>
<p>  ![alt text][base64str]<br>  [base64str]:data:image/png;base64,iV…</p>
<pre><code>
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://fss-angel.top/2021/03/18/Markdown-cheatsheet/" data-id="ckmoqbunh0001gko240n63mde" data-title="Markdown cheatsheet" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Learn-random-module-in-python" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/18/Learn-random-module-in-python/" class="article-date">
  <time class="dt-published" datetime="2021-03-18T09:04:28.000Z" itemprop="datePublished">2021-03-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/18/Learn-random-module-in-python/">Learn random module in python</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://fss-angel.top/2021/03/18/Learn-random-module-in-python/" data-id="ckmoqbunb0000gko2e653e9c9" data-title="Learn random module in python" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/04/25/CNF/">CNF</a>
          </li>
        
          <li>
            <a href="/2021/03/24/vscode-set-get-executionPolicy/">vscode set/get-executionPolicy</a>
          </li>
        
          <li>
            <a href="/2021/03/22/C%E4%B8%AD%E9%A2%84%E7%BC%96%E8%AF%91%E5%AE%8F/">C中预编译宏</a>
          </li>
        
          <li>
            <a href="/2021/03/20/ssh-keygen/">ssh-key-Generate a new SSH Key</a>
          </li>
        
          <li>
            <a href="/2021/03/18/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 FSS-ANGEL<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>